{"version":3,"sources":["../src/index.ts","../src/types.ts","../src/jose.ts","../src/customer.ts","../src/jwks.ts","../src/license.ts","../src/cdn.ts","../src/bots.ts"],"sourcesContent":["import {\n  SupertabConnectConfig,\n  EnforcementMode,\n  BotDetector,\n  HandlerAction,\n  HandlerResult,\n  EventPayload,\n  FASTLY_BACKEND,\n  LicenseTokenInvalidReason,\n  LicenseTokenVerificationResult,\n  Env,\n} from \"./types\";\nimport { obtainLicenseToken as obtainLicenseTokenHelper } from \"./customer\";\nimport {\n  buildBlockResult,\n  buildSignalResult,\n  verifyLicenseToken as verifyLicenseTokenHelper,\n  validateTokenAndBuildResult,\n} from \"./license\";\nimport {\n  handleCloudflareRequest,\n  handleFastlyRequest,\n  handleCloudfrontRequest,\n} from \"./cdn\";\nimport {\n  CloudFrontRequestEvent,\n  CloudFrontRequestResult,\n  CloudfrontHandlerOptions,\n} from \"./types\";\n\nexport { EnforcementMode, HandlerAction };\nexport type {\n  Env,\n  BotDetector,\n  HandlerResult,\n  CloudFrontRequestEvent,\n  CloudFrontRequestResult,\n  CloudfrontHandlerOptions,\n};\nexport { defaultBotDetector } from \"./bots\";\n\n/**\n * SupertabConnect class provides higher level methods\n * for using Supertab Connect within supported CDN integrations\n * as well as more specialized methods to customarily verify JWT tokens and record events.\n */\nexport class SupertabConnect {\n  private apiKey?: string;\n  private static baseUrl: string = \"https://api-connect.supertab.co\";\n  private merchantSystemUrn!: string;\n  private enforcement!: EnforcementMode;\n  private botDetector?: BotDetector;\n  private debug!: boolean;\n\n  private static _instance: SupertabConnect | null = null;\n\n  public constructor(config: SupertabConnectConfig, reset: boolean = false) {\n    if (!reset && SupertabConnect._instance) {\n      // If reset was not requested and an instance conflicts with the provided config, throw an error\n      if (\n        !(\n          config.apiKey === SupertabConnect._instance.apiKey &&\n          config.merchantSystemUrn ===\n            SupertabConnect._instance.merchantSystemUrn\n        )\n      ) {\n        throw new Error(\n          \"Cannot create a new instance with different configuration. Use resetInstance to clear the existing instance.\"\n        );\n      }\n\n      // If an instance already exists and reset is not requested, just return the existing instance\n      return SupertabConnect._instance;\n    }\n    if (reset && SupertabConnect._instance) {\n      // ...and if reset is requested and required, clear the existing instance first\n      SupertabConnect.resetInstance();\n    }\n\n    if (!config.apiKey || !config.merchantSystemUrn) {\n      throw new Error(\n        \"Missing required configuration: apiKey and merchantSystemUrn are required\"\n      );\n    }\n    this.apiKey = config.apiKey;\n    this.merchantSystemUrn = config.merchantSystemUrn;\n    this.enforcement = config.enforcement ?? EnforcementMode.SOFT;\n    this.botDetector = config.botDetector;\n    this.debug = config.debug ?? false;\n\n    // Register this as the singleton instance\n    SupertabConnect._instance = this;\n  }\n\n  public static resetInstance(): void {\n    SupertabConnect._instance = null;\n  }\n\n  /**\n   * Override the default base URL for API requests (intended for local development/testing).\n   */\n  public static setBaseUrl(url: string): void {\n    SupertabConnect.baseUrl = url;\n  }\n\n  /**\n   * Get the current base URL for API requests.\n   */\n  public static getBaseUrl(): string {\n    return SupertabConnect.baseUrl;\n  }\n\n  /**\n   * Verify a license token\n   * @param licenseToken The license token to verify\n   * @param requestUrl The URL of the request being made\n   * @returns A promise that resolves with the verification result\n   */\n  async verifyLicenseToken(\n    licenseToken: string,\n    requestUrl: string\n  ): Promise<LicenseTokenVerificationResult> {\n    return verifyLicenseTokenHelper({\n      licenseToken,\n      requestUrl,\n      supertabBaseUrl: SupertabConnect.baseUrl,\n      debug: this.debug,\n    });\n  }\n\n  /**\n   * Records an analytics event\n   * @param eventName Name of the event to record\n   * @param properties Additional properties to include with the event\n   * @param licenseId Optional license ID associated with the event\n   * @returns Promise that resolves when the event is recorded\n   */\n  async recordEvent(\n    eventName: string,\n    properties: Record<string, any> = {},\n    licenseId?: string\n  ): Promise<void> {\n    const payload: EventPayload = {\n      event_name: eventName,\n      merchant_system_urn: this.merchantSystemUrn ? this.merchantSystemUrn : \"\",\n      license_id: licenseId,\n      properties,\n    };\n\n    try {\n      let options: any = {\n        method: \"POST\",\n        headers: {\n          Authorization: `Bearer ${this.apiKey}`,\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify(payload),\n      };\n      // @ts-ignore\n      if (globalThis?.fastly) {\n        options = { ...options, backend: FASTLY_BACKEND };\n      }\n      const response = await fetch(\n        `${SupertabConnect.baseUrl}/events`,\n        options\n      );\n\n      if (!response.ok) {\n        console.log(`Failed to record event: ${response.status}`);\n      }\n    } catch (error) {\n      console.log(\"Error recording event:\", error);\n    }\n  }\n\n  async handleRequest(request: Request, ctx?: any): Promise<HandlerResult> {\n    const auth = request.headers.get(\"Authorization\") || \"\";\n    const token = auth.startsWith(\"License \") ? auth.slice(8) : null;\n    const url = request.url;\n    const userAgent = request.headers.get(\"User-Agent\") || \"unknown\";\n\n    // Token present → ALWAYS validate, regardless of mode or bot detection\n    if (token) {\n      if (this.enforcement === EnforcementMode.DISABLED) {\n        return { action: HandlerAction.ALLOW };\n      }\n      return validateTokenAndBuildResult({\n        token,\n        url,\n        userAgent,\n        supertabBaseUrl: SupertabConnect.baseUrl,\n        debug: this.debug,\n        recordEvent: this.recordEvent.bind(this),\n        ctx,\n      });\n    }\n\n    // No token from here on\n    const isBot = this.botDetector?.(request, ctx) ?? false;\n\n    if (!isBot) {\n      return { action: HandlerAction.ALLOW };\n    }\n\n    // Bot detected, no token — enforcement mode decides\n    switch (this.enforcement) {\n      case EnforcementMode.STRICT:\n        return buildBlockResult({\n          reason: LicenseTokenInvalidReason.MISSING_TOKEN,\n          requestUrl: url,\n          supertabBaseUrl: SupertabConnect.baseUrl,\n        });\n      case EnforcementMode.SOFT:\n        return buildSignalResult(url);\n      default: // DISABLED\n        return { action: HandlerAction.ALLOW };\n    }\n  }\n\n  /**\n   * Request a license token from the Supertab Connect token endpoint.\n   * Automatically fetches and parses license.xml from the resource URL's origin,\n   * using the token endpoint specified in the matching content element's server attribute.\n   * @param clientId OAuth client identifier.\n   * @param clientSecret OAuth client secret for client_credentials flow.\n   * @param resourceUrl Resource URL attempting to access with a License.\n   * @param debug Enable debug logging (default: false).\n   * @returns Promise resolving to the issued license access token string.\n   */\n  static async obtainLicenseToken(\n    clientId: string,\n    clientSecret: string,\n    resourceUrl: string,\n    debug: boolean = false\n  ): Promise<string> {\n    return obtainLicenseTokenHelper({\n      clientId,\n      clientSecret,\n      resourceUrl,\n      debug,\n    });\n  }\n\n  /**\n   * Handle incoming requests for Cloudflare Workers.\n   */\n  static async cloudflareHandleRequests(\n    request: Request,\n    env: Env,\n    ctx: any\n  ): Promise<Response> {\n    const instance = new SupertabConnect({\n      apiKey: env.MERCHANT_API_KEY,\n      merchantSystemUrn: env.MERCHANT_SYSTEM_URN,\n    });\n    return handleCloudflareRequest(instance, request, ctx);\n  }\n\n  /**\n   * Handle incoming requests for Fastly Compute.\n   */\n  static async fastlyHandleRequests(\n    request: Request,\n    merchantSystemUrn: string,\n    merchantApiKey: string,\n    originBackend: string,\n    options?: {\n      enableRSL?: boolean;\n      botDetector?: BotDetector;\n      enforcement?: EnforcementMode;\n    }\n  ): Promise<Response> {\n    const { enableRSL = false, botDetector, enforcement } = options ?? {};\n\n    const instance = new SupertabConnect({\n      apiKey: merchantApiKey,\n      merchantSystemUrn: merchantSystemUrn,\n      botDetector,\n      enforcement,\n    });\n\n    return handleFastlyRequest(\n      instance,\n      request,\n      originBackend,\n      enableRSL\n        ? {\n            baseUrl: SupertabConnect.baseUrl,\n            merchantSystemUrn,\n          }\n        : undefined\n    );\n  }\n\n  /**\n   * Handle incoming requests for AWS CloudFront Lambda@Edge.\n   */\n  static async cloudfrontHandleRequests<TRequest extends Record<string, any>>(\n    event: CloudFrontRequestEvent<TRequest>,\n    options: CloudfrontHandlerOptions\n  ): Promise<CloudFrontRequestResult<TRequest>> {\n    const instance = new SupertabConnect({\n      apiKey: options.apiKey,\n      merchantSystemUrn: options.merchantSystemUrn,\n      botDetector: options.botDetector,\n      enforcement: options.enforcement,\n    });\n    return handleCloudfrontRequest(instance, event);\n  }\n}\n","export enum EnforcementMode {\n  DISABLED = \"disabled\",\n  SOFT = \"soft\",\n  STRICT = \"strict\",\n}\n\nexport type BotDetector = (request: Request, ctx?: any) => boolean;\n\nexport interface SupertabConnectConfig {\n  apiKey: string;\n  merchantSystemUrn: string;\n  enforcement?: EnforcementMode;\n  botDetector?: BotDetector;\n  debug?: boolean;\n}\n\n/**\n * Defines the shape for environment variables (used in CloudFlare integration).\n * These are used to identify and authenticate the Merchant System with the Supertab Connect API.\n */\nexport interface Env {\n\t/** The unique identifier for the merchant system. */\n\tMERCHANT_SYSTEM_URN: string;\n\t/** The API key for authenticating with the Supertab Connect. */\n\tMERCHANT_API_KEY: string;\n\t[key: string]: string;\n}\n\nexport interface EventPayload {\n  event_name: string;\n  license_id?: string;\n  merchant_system_urn: string;\n  properties: Record<string, any>;\n}\n\nexport type LicenseTokenVerificationResult =\n  | { valid: true; licenseId?: string; payload: any }\n  | { valid: false; reason: LicenseTokenInvalidReason; licenseId?: string };\n\nexport enum LicenseTokenInvalidReason {\n  MISSING_TOKEN = \"missing_license_token\",\n  INVALID_HEADER = \"invalid_license_header\",\n  INVALID_ALG = \"invalid_license_algorithm\",\n  INVALID_PAYLOAD = \"invalid_license_payload\",\n  INVALID_ISSUER = \"invalid_license_issuer\",\n  SIGNATURE_VERIFICATION_FAILED = \"license_signature_verification_failed\",\n  EXPIRED = \"license_token_expired\",\n  INVALID_AUDIENCE = \"invalid_license_audience\",\n  SERVER_ERROR = \"server_error\",\n}\n\nexport const FASTLY_BACKEND = \"stc-backend\";\n\nexport interface FetchOptions extends RequestInit {\n  // Fastly-specific extension for backend routing\n  backend?: string;\n}\n\nexport enum HandlerAction {\n  ALLOW = \"allow\",\n  BLOCK = \"block\",\n}\n\nexport type HandlerResult =\n  | { action: HandlerAction.ALLOW; headers?: Record<string, string> }\n  | { action: HandlerAction.BLOCK; status: number; body: string; headers: Record<string, string> };\n\n// CloudFront Lambda@Edge types\n// Uses permissive types to be compatible with aws-lambda package types\nexport interface CloudFrontHeaders {\n  [key: string]: Array<{ key?: string; value: string }>;\n}\n\nexport interface CloudFrontResultResponse {\n  status: string;\n  statusDescription?: string;\n  headers?: CloudFrontHeaders;\n  bodyEncoding?: \"text\" | \"base64\";\n  body?: string;\n}\n\n// CloudFrontRequestEvent uses a generic request type to accept aws-lambda's CloudFrontRequest\nexport interface CloudFrontRequestEvent<TRequest = Record<string, any>> {\n  Records: Array<{\n    cf: {\n      config?: {\n        distributionDomainName?: string;\n        distributionId?: string;\n        eventType?: string;\n        requestId?: string;\n      };\n      request: TRequest & {\n        uri: string;\n        method: string;\n        querystring: string;\n        headers: CloudFrontHeaders;\n      };\n    };\n  }>;\n}\n\n// Result can be either the original request (pass-through) or a response\n// Using generic to preserve the original request type for pass-through\nexport type CloudFrontRequestResult<TRequest = Record<string, any>> = TRequest | CloudFrontResultResponse;\n\nexport interface CloudfrontHandlerOptions {\n  apiKey: string;\n  merchantSystemUrn: string;\n  botDetector?: BotDetector;\n  enforcement?: EnforcementMode;\n}","type JoseModule = typeof import(\"jose\");\n\nlet joseModulePromise: Promise<JoseModule> | null = null;\n\n/**\n * Lazily load the ESM-only `jose` package so the CommonJS build can call it via dynamic import.\n */\nexport function loadJose(): Promise<JoseModule> {\n  if (!joseModulePromise) {\n    joseModulePromise = import(\"jose\");\n  }\n  return joseModulePromise;\n}\n","import { loadJose } from \"./jose\";\n\ntype SupportedAlg = \"RS256\" | \"ES256\";\n\ntype GenerateLicenseTokenParams = {\n  clientId: string;\n  kid: string;\n  privateKeyPem: string;\n  tokenEndpoint: string;\n  resourceUrl: string;\n  licenseXml: string;\n  debug?: boolean;\n};\n\ntype ObtainLicenseTokenParams = {\n  clientId: string;\n  clientSecret: string;\n  resourceUrl: string;\n  debug?: boolean;\n};\n\ntype ContentBlock = {\n  urlPattern: string;\n  licenseXml: string;\n  server: string;\n};\n\nasync function retrieveLicenseToken(\n    tokenEndpoint: string,\n    requestOptions: RequestInit,\n    debug: boolean | undefined\n) {\n  try {\n    const response = await fetch(tokenEndpoint, requestOptions);\n\n    if (!response.ok) {\n      const errorBody = await response.text().catch(() => \"\");\n      const errorMessage = `Failed to obtain license token: ${\n        response.status\n      } ${response.statusText}${errorBody ? ` - ${errorBody}` : \"\"}`;\n      throw new Error(errorMessage);\n    }\n\n    let data: any;\n    try {\n      data = await response.json();\n    } catch (parseError) {\n      if (debug) {\n        console.error(\n          \"Failed to parse license token response as JSON:\",\n          parseError\n        );\n      }\n      throw new Error(\"Failed to parse license token response as JSON\");\n    }\n\n    if (!data?.access_token) {\n      throw new Error(\"License token response missing access_token\");\n    }\n\n    return data.access_token;\n  } catch (error) {\n    if (debug) {\n      console.error(\"Error generating license token:\", error);\n    }\n    throw error;\n  }\n}\n\nasync function importKeyForAlgs(\n  privateKeyPem: string,\n  debug: boolean | undefined\n): Promise<{ key: CryptoKey; alg: SupportedAlg }> {\n  const { importPKCS8 } = await loadJose();\n  const supportedAlgs: SupportedAlg[] = [\"ES256\", \"RS256\"];\n\n  for (const algorithm of supportedAlgs) {\n    try {\n      const key = await importPKCS8(privateKeyPem, algorithm);\n      return { key, alg: algorithm };\n    } catch (importError) {\n      if (debug) {\n        console.debug(\n          `Private key did not import using ${algorithm}, retrying...`,\n          importError\n        );\n      }\n    }\n  }\n\n  throw new Error(\n    \"Unsupported private key format. Expected RSA or P-256 EC private key.\"\n  );\n}\n\n// Temporarily not exporting this function to reflect only client credentials flow being supported\nasync function generateLicenseToken({\n  clientId,\n  kid,\n  privateKeyPem,\n  tokenEndpoint,\n  resourceUrl,\n  licenseXml,\n  debug,\n}: GenerateLicenseTokenParams): Promise<string> {\n  const { SignJWT } = await loadJose();\n  const { key, alg } = await importKeyForAlgs(privateKeyPem, debug);\n  const now = Math.floor(Date.now() / 1000);\n\n  const clientAssertion = await new SignJWT({})\n    .setProtectedHeader({ alg, kid })\n    .setIssuer(clientId)\n    .setSubject(clientId)\n    .setIssuedAt(now)\n    .setExpirationTime(now + 300)\n    .setAudience(tokenEndpoint)\n    .sign(key);\n\n  const payload = new URLSearchParams({\n    grant_type: \"rsl\",\n    client_assertion_type:\n      \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\",\n    client_assertion: clientAssertion,\n    license: licenseXml,\n    resource: resourceUrl,\n  });\n\n  const requestOptions: RequestInit = {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/x-www-form-urlencoded\",\n      Accept: \"application/json\",\n    },\n    body: payload.toString(),\n  };\n\n  return retrieveLicenseToken(tokenEndpoint, requestOptions, debug);\n}\n\nasync function fetchLicenseXml(\n  resourceUrl: string,\n  debug: boolean | undefined\n): Promise<string> {\n  const origin = new URL(resourceUrl).origin;\n  const licenseXmlUrl = `${origin}/license.xml`;\n\n  const response = await fetch(licenseXmlUrl);\n  if (!response.ok) {\n    if (debug) {\n      console.error(`Failed to fetch license.xml from ${licenseXmlUrl}: ${response.status}`);\n    }\n    throw new Error(\n      `Failed to fetch license.xml from ${licenseXmlUrl}: ${response.status}`\n    );\n  }\n\n  const xml = await response.text();\n  if (debug) {\n    console.debug(\"Fetched license.xml from\", licenseXmlUrl);\n  }\n  return xml;\n}\n\nfunction parseContentElements(xml: string, debug?: boolean): ContentBlock[] {\n  const contentBlocks: ContentBlock[] = [];\n  const contentRegex = /<content\\s([^>]*)>([\\s\\S]*?)<\\/content>/gi;\n  const urlRegex = /url\\s*=\\s*\"([^\"]*)\"/i;\n  const serverRegex = /server\\s*=\\s*\"([^\"]*)\"/i;\n  const licenseRegex = /<license[^>]*>[\\s\\S]*?<\\/license>/i;\n\n  let elementCount = 0;\n  let match;\n  while ((match = contentRegex.exec(xml)) !== null) {\n    elementCount++;\n    const attrs = match[1];\n    const body = match[2];\n    const urlMatch = attrs.match(urlRegex);\n    const serverMatch = attrs.match(serverRegex);\n    const licenseMatch = body.match(licenseRegex);\n\n    if (urlMatch && serverMatch && licenseMatch) {\n      contentBlocks.push({\n        urlPattern: urlMatch[1],\n        server: serverMatch[1],\n        licenseXml: licenseMatch[0],\n      });\n    } else if (debug) {\n      const missing = [\n        !urlMatch && \"url\",\n        !serverMatch && \"server\",\n        !licenseMatch && \"<license>\",\n      ].filter(Boolean).join(\", \");\n      console.debug(`Skipping <content> element #${elementCount}: missing ${missing}`);\n    }\n  }\n\n  if (debug) {\n    console.debug(`Found ${elementCount} <content> element(s), ${contentBlocks.length} valid`);\n  }\n\n  return contentBlocks;\n}\n\nfunction findBestMatchingContent(\n  contentBlocks: ContentBlock[],\n  resourceUrl: string,\n  debug?: boolean\n): ContentBlock | null {\n  const parsed = new URL(resourceUrl);\n  const host = parsed.host;\n  const path = parsed.pathname;\n\n  if (debug) {\n    console.debug(`Matching resource URL: ${resourceUrl} (host=${host}, path=${path})`);\n  }\n\n  let bestMatch: ContentBlock | null = null;\n  let bestSpecificity = -1;\n\n  for (const block of contentBlocks) {\n    let patternUrl: URL;\n    try {\n      patternUrl = new URL(block.urlPattern);\n    } catch {\n      if (debug) {\n        console.debug(`Skipping block with invalid URL pattern: ${block.urlPattern}`);\n      }\n      continue;\n    }\n\n    if (patternUrl.host !== host) {\n      if (debug) {\n        console.debug(`Skipping block: host mismatch (pattern=${patternUrl.host}, resource=${host})`);\n      }\n      continue;\n    }\n\n    const patternPath = patternUrl.pathname;\n\n    if (patternPath === path) {\n      if (debug) {\n        console.debug(`Exact match found: ${block.urlPattern}`);\n      }\n      return block;\n    }\n\n    if (patternPath.endsWith(\"/*\")) {\n      const prefix = patternPath.slice(0, -1); // remove trailing *\n      if (path.startsWith(prefix)) {\n        const specificity = prefix.length;\n        if (specificity > bestSpecificity) {\n          bestSpecificity = specificity;\n          bestMatch = block;\n        }\n      }\n    }\n  }\n\n  if (debug) {\n    if (bestMatch) {\n      console.debug(`Wildcard match found: ${bestMatch.urlPattern} (specificity=${bestSpecificity})`);\n    } else {\n      console.debug(`No matching content block found for ${resourceUrl}`);\n    }\n  }\n\n  return bestMatch;\n}\n\nexport { parseContentElements, findBestMatchingContent };\nexport type { ContentBlock };\n\nexport async function obtainLicenseToken({\n  clientId,\n  clientSecret,\n  resourceUrl,\n  debug,\n}: ObtainLicenseTokenParams): Promise<string> {\n  const xml = await fetchLicenseXml(resourceUrl, debug);\n  if (debug) {\n    console.debug(`Fetched license.xml (${xml.length} chars)`);\n  }\n  const contentBlocks = parseContentElements(xml, debug);\n\n  if (contentBlocks.length === 0) {\n    if (debug) {\n      console.error(\"No valid <content> elements with <license> found in license.xml\");\n    }\n    throw new Error(\n      \"No valid <content> elements with <license> found in license.xml\"\n    );\n  }\n\n  const matchedContent = findBestMatchingContent(contentBlocks, resourceUrl, debug);\n  if (!matchedContent) {\n    if (debug) {\n      const patterns = contentBlocks.map(b => b.urlPattern).join(\", \");\n      console.error(`No <content> element matches resource URL: ${resourceUrl}. Available patterns: ${patterns}`);\n    }\n    throw new Error(\n      `No <content> element in license.xml matches resource URL: ${resourceUrl}`\n    );\n  }\n\n  if (debug) {\n    console.debug(\"Matched content block for resource URL:\", resourceUrl);\n    console.debug(\"Using license XML:\", matchedContent.licenseXml);\n  }\n\n  const tokenEndpoint = matchedContent.server + '/token';\n  if (debug) {\n    console.debug(`Requesting license token from ${tokenEndpoint}`);\n  }\n\n  const payload = new URLSearchParams({\n    grant_type: \"client_credentials\",\n    license: matchedContent.licenseXml,\n    resource: matchedContent.urlPattern,\n  });\n\n  const requestOptions: RequestInit = {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/x-www-form-urlencoded\",\n      Accept: \"application/json\",\n      Authorization: \"Basic \" + btoa(`${clientId}:${clientSecret}`),\n    },\n    body: payload.toString(),\n  };\n\n  return retrieveLicenseToken(tokenEndpoint, requestOptions, debug);\n}\n\nexport type { ObtainLicenseTokenParams };\n","import { FASTLY_BACKEND, FetchOptions } from \"./types\";\n\nconst jwksCache = new Map<string, any>();\n\ntype JwksCacheKey = string;\n\ntype FetchJwksParams = {\n  cacheKey: JwksCacheKey;\n  url: string;\n  debug: boolean;\n  failureMessage: string;\n  logLabel: string;\n};\n\nfunction buildFetchOptions(): FetchOptions {\n  let options: FetchOptions = { method: \"GET\" };\n  // @ts-ignore - backend is a Fastly-specific extension\n  if (globalThis?.fastly) {\n    options = { ...options, backend: FASTLY_BACKEND };\n  }\n  return options;\n}\n\nasync function fetchAndCacheJwks({\n  cacheKey,\n  url,\n  debug,\n  failureMessage,\n  logLabel,\n}: FetchJwksParams): Promise<any> {\n  if (!jwksCache.has(cacheKey)) {\n    try {\n      const response = await fetch(url, buildFetchOptions());\n\n      if (!response.ok) {\n        throw new Error(`${failureMessage}: ${response.status}`);\n      }\n\n      const jwksData = await response.json();\n      jwksCache.set(cacheKey, jwksData);\n    } catch (error) {\n      if (debug) {\n        console.error(logLabel, error);\n      }\n      throw error;\n    }\n  }\n\n  return jwksCache.get(cacheKey);\n}\n\nexport async function fetchPlatformJwks(\n  baseUrl: string,\n  debug: boolean\n): Promise<any> {\n  const jwksUrl = `${baseUrl}/.well-known/jwks.json/platform`;\n  if (debug) {\n    console.debug(`Fetching platform JWKS from URL: ${jwksUrl}`);\n  }\n\n  return fetchAndCacheJwks({\n    cacheKey: \"platform_jwks\",\n    url: jwksUrl,\n    debug,\n    failureMessage: \"Failed to fetch platform JWKS\",\n    logLabel: \"Error fetching platform JWKS:\",\n  });\n}\n\nexport function clearJwksCache(): void {\n  jwksCache.clear();\n}\n","import type { JWTPayload, JWTHeaderParameters } from \"jose\";\nimport { loadJose } from \"./jose\";\n\ninterface LicenseJWTPayload extends JWTPayload {\n  license_id?: string;\n}\nimport {\n  HandlerAction,\n  HandlerResult,\n  LicenseTokenInvalidReason,\n  LicenseTokenVerificationResult,\n  FASTLY_BACKEND,\n  FetchOptions,\n} from \"./types\";\nimport { fetchPlatformJwks } from \"./jwks\";\n\nexport type EventRecorder = (\n  eventName: string,\n  properties: Record<string, any>,\n  licenseId?: string\n) => Promise<void>;\n\nconst stripTrailingSlash = (value: string) => value.trim().replace(/\\/+$/, \"\");\n\nexport type VerifyLicenseTokenParams = {\n  licenseToken: string;\n  requestUrl: string;\n  supertabBaseUrl: string;\n  debug: boolean;\n};\n\nexport async function verifyLicenseToken({\n  licenseToken,\n  requestUrl,\n  supertabBaseUrl,\n  debug,\n}: VerifyLicenseTokenParams): Promise<LicenseTokenVerificationResult> {\n  const { decodeProtectedHeader, decodeJwt, jwtVerify } = await loadJose();\n\n  if (!licenseToken) {\n    return {\n      valid: false,\n      reason: LicenseTokenInvalidReason.MISSING_TOKEN,\n    };\n  }\n\n  let header: JWTHeaderParameters;\n  try {\n    header = decodeProtectedHeader(licenseToken) as JWTHeaderParameters;\n  } catch (error) {\n    if (debug) {\n      console.error(\"Invalid license JWT header:\", error);\n    }\n    return {\n      valid: false,\n      reason: LicenseTokenInvalidReason.INVALID_HEADER,\n    };\n  }\n\n  if (header.alg !== \"ES256\") {\n    if (debug) {\n      console.error(\"Unsupported license JWT alg:\", header.alg);\n    }\n    return {\n      valid: false,\n      reason: LicenseTokenInvalidReason.INVALID_ALG,\n    };\n  }\n\n  let payload: LicenseJWTPayload;\n  try {\n    payload = decodeJwt(licenseToken) as LicenseJWTPayload;\n  } catch (error) {\n    if (debug) {\n      console.error(\"Invalid license JWT payload:\", error);\n    }\n    return {\n      valid: false,\n      reason: LicenseTokenInvalidReason.INVALID_PAYLOAD,\n    };\n  }\n\n  const licenseId: string | undefined = payload.license_id;\n\n  const issuer: string | undefined = payload.iss;\n  const normalizedIssuer = issuer ? stripTrailingSlash(issuer) : undefined;\n  const normalizedBaseUrl = stripTrailingSlash(supertabBaseUrl);\n\n  if (!normalizedIssuer || !normalizedIssuer.startsWith(normalizedBaseUrl)) {\n    if (debug) {\n      console.error(\"License JWT issuer is missing or malformed:\", issuer);\n    }\n    return {\n      valid: false,\n      reason: LicenseTokenInvalidReason.INVALID_ISSUER,\n      licenseId,\n    };\n  }\n\n  const audienceValues = Array.isArray(payload.aud)\n    ? payload.aud.filter((entry): entry is string => typeof entry === \"string\")\n    : typeof payload.aud === \"string\"\n    ? [payload.aud]\n    : [];\n\n  const requestUrlNormalized = stripTrailingSlash(requestUrl);\n  const matchesRequestUrl = audienceValues.some((value) => {\n    const normalizedAudience = stripTrailingSlash(value);\n    if (!normalizedAudience) return false;\n    return requestUrlNormalized.startsWith(normalizedAudience);\n  });\n\n  if (!matchesRequestUrl) {\n    if (debug) {\n      console.error(\n        \"License JWT audience does not match request URL:\",\n        payload.aud\n      );\n    }\n    return {\n      valid: false,\n      reason: LicenseTokenInvalidReason.INVALID_AUDIENCE,\n      licenseId,\n    };\n  }\n\n  let jwks;\n  try {\n    jwks = await fetchPlatformJwks(supertabBaseUrl, debug);\n  } catch (error) {\n    if (debug) {\n      console.error(\"Failed to fetch platform JWKS:\", error);\n    }\n    return {\n      valid: false,\n      reason: LicenseTokenInvalidReason.SERVER_ERROR,\n      licenseId,\n    };\n  }\n\n  try {\n    const getKey = async (jwtHeader: JWTHeaderParameters) => {\n      const jwk = jwks.keys.find((key: any) => key.kid === jwtHeader.kid);\n      if (!jwk) {\n        throw new Error(`No matching platform key found: ${jwtHeader.kid}`);\n      }\n      return jwk;\n    };\n\n    const result = await jwtVerify(licenseToken, getKey, {\n      issuer,\n      algorithms: [header.alg],\n      clockTolerance: \"1m\",\n    });\n\n    return {\n      valid: true,\n      licenseId,\n      payload: result.payload,\n    };\n  } catch (error) {\n    if (debug) {\n      console.error(\"License JWT verification failed:\", error);\n    }\n\n    if (error instanceof Error && error.message?.includes(\"exp\")) {\n      return {\n        valid: false,\n        reason: LicenseTokenInvalidReason.EXPIRED,\n        licenseId,\n      };\n    }\n\n    return {\n      valid: false,\n      reason: LicenseTokenInvalidReason.SIGNATURE_VERIFICATION_FAILED,\n      licenseId,\n    };\n  }\n}\n\nexport function generateLicenseLink({\n  requestUrl,\n}: {\n  requestUrl: string;\n}): string {\n  const baseURL = new URL(requestUrl);\n  return `${baseURL.protocol}//${baseURL.host}/license.xml`;\n}\n\n/**\n * Build a HandlerResult that signals a missing token in soft enforcement mode.\n * Returns headers indicating a license is required without blocking the request.\n */\nexport function buildSignalResult(requestUrl: string): HandlerResult {\n  const licenseLink = generateLicenseLink({ requestUrl });\n  return {\n    action: HandlerAction.ALLOW,\n    headers: {\n      Link: `<${licenseLink}>; rel=\"license\"; type=\"application/rsl+xml\"`,\n      \"X-RSL-Status\": \"token_required\",\n      \"X-RSL-Reason\": \"missing\",\n    },\n  };\n}\nexport function buildBlockResult({\n  reason,\n  requestUrl,\n  supertabBaseUrl,\n}: {\n  reason: LicenseTokenInvalidReason | string;\n  requestUrl: string;\n  supertabBaseUrl: string;\n}): HandlerResult {\n  let rslError: string;\n  let errorDescription: string;\n  let status: number;\n\n  switch (reason) {\n    // 401 — invalid_request: missing or malformed request\n    case LicenseTokenInvalidReason.MISSING_TOKEN:\n      status = 401;\n      rslError = \"invalid_request\";\n      errorDescription = \"Authorization header missing or malformed\";\n      break;\n    case LicenseTokenInvalidReason.INVALID_ALG:\n      status = 401;\n      rslError = \"invalid_request\";\n      errorDescription = \"Unsupported token algorithm\";\n      break;\n\n    // 401 — invalid_token: token exists but is bad\n    case LicenseTokenInvalidReason.EXPIRED:\n      status = 401;\n      rslError = \"invalid_token\";\n      errorDescription = \"The license token has expired\";\n      break;\n    case LicenseTokenInvalidReason.SIGNATURE_VERIFICATION_FAILED:\n      status = 401;\n      rslError = \"invalid_token\";\n      errorDescription = \"The license token signature is invalid\";\n      break;\n    case LicenseTokenInvalidReason.INVALID_HEADER:\n      status = 401;\n      rslError = \"invalid_token\";\n      errorDescription = \"The license token header is malformed\";\n      break;\n    case LicenseTokenInvalidReason.INVALID_PAYLOAD:\n      status = 401;\n      rslError = \"invalid_token\";\n      errorDescription = \"The license token payload is malformed\";\n      break;\n    case LicenseTokenInvalidReason.INVALID_ISSUER:\n      status = 401;\n      rslError = \"invalid_token\";\n      errorDescription = \"The license token issuer is not recognized\";\n      break;\n    // 403 — insufficient_scope: valid token, wrong resource/usage\n    case LicenseTokenInvalidReason.INVALID_AUDIENCE:\n      status = 403;\n      rslError = \"insufficient_scope\";\n      errorDescription = \"The license does not grant access to this resource\";\n      break;\n    // 503 — server-side validation failure\n    case LicenseTokenInvalidReason.SERVER_ERROR:\n      status = 503;\n      rslError = \"server_error\";\n      errorDescription = \"The server encountered an error validating the license\";\n      break;\n\n    default:\n      status = 401;\n      rslError = \"invalid_token\";\n      errorDescription = \"License token missing, expired, revoked, or malformed\";\n  }\n\n  const licenseLink = generateLicenseLink({ requestUrl });\n\n  return {\n    action: HandlerAction.BLOCK,\n    status,\n    body: `Access to this resource requires a valid license token. Error: ${rslError} - ${errorDescription}`,\n    headers: {\n    \"Content-Type\": \"text/plain; charset=UTF-8\",\n    \"WWW-Authenticate\": `License error=\"${rslError}\", error_description=\"${errorDescription}\"`,\n    Link: `<${licenseLink}>; rel=\"license\"; type=\"application/rsl+xml\"`,\n  },\n  };\n}\n\nfunction buildFetchOptions(): FetchOptions {\n  let options: FetchOptions = { method: \"GET\" };\n  // @ts-ignore - backend is a Fastly-specific extension\n  if (globalThis?.fastly) {\n    options = { ...options, backend: FASTLY_BACKEND };\n  }\n  return options;\n}\n\nexport async function hostRSLicenseXML(\n  supertabBaseUrl: string,\n  merchantSystemUrn: string\n): Promise<Response> {\n  const licenseUrl = `${supertabBaseUrl}/merchants/systems/${merchantSystemUrn}/license.xml`;\n  const response = await fetch(licenseUrl, buildFetchOptions());\n\n  if (!response.ok) {\n    return new Response(\"License not found\", { status: 404 });\n  }\n\n  const licenseXml = await response.text();\n\n  return new Response(licenseXml, {\n    status: 200,\n    headers: new Headers({ \"Content-Type\": \"application/xml\" }),\n  });\n}\n\nexport type ValidateTokenParams = {\n  token: string;\n  url: string;\n  userAgent: string;\n  supertabBaseUrl: string;\n  debug: boolean;\n  recordEvent?: EventRecorder;\n  ctx?: any;\n};\n\nexport async function validateTokenAndBuildResult(\n  params: ValidateTokenParams\n): Promise<HandlerResult> {\n  const verification = await verifyLicenseToken({\n    licenseToken: params.token,\n    requestUrl: params.url,\n    supertabBaseUrl: params.supertabBaseUrl,\n    debug: params.debug,\n  });\n\n  if (params.recordEvent) {\n    const eventName = verification.valid\n      ? \"license_used\"\n      : verification.reason;\n\n    const eventProperties = {\n      page_url: params.url,\n      user_agent: params.userAgent,\n      verification_status: verification.valid ? \"valid\" : \"invalid\",\n      verification_reason: verification.valid ? \"success\" : verification.reason,\n    };\n\n    const eventPromise = params.recordEvent(\n      eventName,\n      eventProperties,\n      verification.licenseId\n    );\n\n    if (params.ctx?.waitUntil) {\n      params.ctx.waitUntil(eventPromise);\n    }\n  }\n\n  if (!verification.valid) {\n    return buildBlockResult({\n      reason: verification.reason,\n      requestUrl: params.url,\n      supertabBaseUrl: params.supertabBaseUrl,\n    });\n  }\n\n  return { action: HandlerAction.ALLOW };\n}\n","import {\n  HandlerAction,\n  HandlerResult,\n  CloudFrontHeaders,\n  CloudFrontRequestEvent,\n  CloudFrontRequestResult,\n} from \"./types\";\nimport { hostRSLicenseXML } from \"./license\";\n\n// Interface for what the CDN handlers need - avoids circular dependency\ninterface RequestHandler {\n  handleRequest(request: Request, ctx?: any): Promise<HandlerResult>;\n}\n\nexport async function handleCloudflareRequest(\n  handler: RequestHandler,\n  request: Request,\n  ctx: any\n): Promise<Response> {\n  const result = await handler.handleRequest(request, ctx);\n\n  if (result.action === HandlerAction.BLOCK) {\n    return new Response(result.body, {\n      status: result.status,\n      headers: new Headers(result.headers),\n    });\n  }\n\n  // action === HandlerAction.ALLOW\n  const originResponse = await fetch(request);\n\n  if (result.headers) {\n    const response = new Response(originResponse.body, originResponse);\n    for (const [key, value] of Object.entries(result.headers)) {\n      response.headers.set(key, value);\n    }\n    return response;\n  }\n\n  return originResponse;\n}\n\nexport async function handleFastlyRequest(\n  handler: RequestHandler,\n  request: Request,\n  originBackend: string,\n  rslOptions?: {\n    baseUrl: string;\n    merchantSystemUrn: string;\n  }\n): Promise<Response> {\n  if (rslOptions && new URL(request.url).pathname === \"/license.xml\") {\n    return await hostRSLicenseXML(\n      rslOptions.baseUrl,\n      rslOptions.merchantSystemUrn\n    );\n  }\n\n  const result = await handler.handleRequest(request);\n\n  if (result.action === HandlerAction.BLOCK) {\n    return new Response(result.body, {\n      status: result.status,\n      headers: new Headers(result.headers),\n    });\n  }\n\n  // action === HandlerAction.ALLOW\n  const originResponse = await fetch(request, {\n    backend: originBackend,\n  } as RequestInit);\n\n  if (result.headers) {\n    const response = new Response(originResponse.body, originResponse);\n    for (const [key, value] of Object.entries(result.headers)) {\n      response.headers.set(key, value);\n    }\n    return response;\n  }\n\n  return originResponse;\n}\n\nexport async function handleCloudfrontRequest<TRequest extends Record<string, any>>(\n  handler: RequestHandler,\n  event: CloudFrontRequestEvent<TRequest>\n): Promise<CloudFrontRequestResult<TRequest>> {\n  const cfRequest = event.Records[0].cf.request;\n\n  // Convert CloudFront request to Web API Request\n  const url = `https://${cfRequest.headers.host[0].value}${cfRequest.uri}${cfRequest.querystring ? \"?\" + cfRequest.querystring : \"\"}`;\n\n  const headers = new Headers();\n  Object.entries(cfRequest.headers).forEach(([key, values]) => {\n    values.forEach(({ value }) => headers.append(key, value));\n  });\n\n  const webRequest = new Request(url, {\n    method: cfRequest.method,\n    headers: headers,\n  });\n\n  const result = await handler.handleRequest(webRequest);\n\n  if (result.action === HandlerAction.BLOCK) {\n    const responseHeaders: CloudFrontHeaders = {};\n    Object.entries(result.headers).forEach(([key, value]) => {\n      responseHeaders[key.toLowerCase()] = [{ key, value }];\n    });\n\n    return {\n      status: result.status.toString(),\n      statusDescription:\n        result.status === 401 ? \"Unauthorized\" : \"Payment Required\",\n      headers: responseHeaders,\n      body: result.body,\n    };\n  }\n\n  // Allow request to continue to origin\n  return cfRequest;\n}\n","/**\n * Default bot detection logic using multiple signals.\n * Checks User-Agent patterns, headless browser indicators, missing headers, and Cloudflare bot scores.\n * @param request The incoming request to analyze\n * @returns true if the request appears to be from a bot, false otherwise\n */\nexport function defaultBotDetector(request: Request): boolean {\n  const userAgent = request.headers.get(\"User-Agent\") || \"\";\n  const accept = request.headers.get(\"accept\") || \"\";\n  const secChUa = request.headers.get(\"sec-ch-ua\");\n  const acceptLanguage = request.headers.get(\"accept-language\");\n  const botScore = (request as any).cf?.botManagement?.score;\n\n  const botList = [\n    \"chatgpt-user\",\n    \"perplexitybot\",\n    \"gptbot\",\n    \"anthropic-ai\",\n    \"ccbot\",\n    \"claude-web\",\n    \"claudebot\",\n    \"cohere-ai\",\n    \"youbot\",\n    \"diffbot\",\n    \"oai-searchbot\",\n    \"meta-externalagent\",\n    \"timpibot\",\n    \"amazonbot\",\n    \"bytespider\",\n    \"perplexity-user\",\n    \"googlebot\",\n    \"bot\",\n    \"curl\",\n    \"wget\",\n  ];\n  // 1. Basic substring check from known list\n  const lowerCaseUserAgent = userAgent.toLowerCase();\n  const botUaMatch = botList.some((bot) => lowerCaseUserAgent.includes(bot));\n\n  // 2. Headless browser detection\n  const headlessIndicators =\n    userAgent.toLowerCase().includes(\"headless\") ||\n    userAgent.toLowerCase().includes(\"puppeteer\") ||\n    !secChUa;\n\n  const isBrowserMissingSecChUa =\n    !userAgent.toLowerCase().includes(\"headless\") &&\n    !userAgent.toLowerCase().includes(\"puppeteer\") &&\n    !secChUa;\n\n  // 3. Suspicious header gaps — many bots omit these\n  const missingHeaders = !accept || !acceptLanguage;\n\n  // 4. Cloudflare bot score check (if available)\n  const lowBotScore = typeof botScore === \"number\" && botScore < 30;\n\n  // Safari and Mozilla special case\n  if (\n    lowerCaseUserAgent.includes(\"safari\") ||\n    lowerCaseUserAgent.includes(\"mozilla\")\n  ) {\n    // Safari is not a bot, but it may be headless\n    if (headlessIndicators && isBrowserMissingSecChUa) {\n      return false; // Likely not a bot, but missing a Sec-CH-UA header\n    }\n  }\n\n  // Final decision\n  return botUaMatch || headlessIndicators || missingHeaders || lowBotScore;\n}\n"],"mappings":"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","names":["index_exports","__export","EnforcementMode","HandlerAction","SupertabConnect","defaultBotDetector","__toCommonJS","EnforcementMode","FASTLY_BACKEND","HandlerAction","joseModulePromise","loadJose","retrieveLicenseToken","tokenEndpoint","requestOptions","debug","response","errorBody","errorMessage","data","parseError","error","fetchLicenseXml","resourceUrl","debug","licenseXmlUrl","response","xml","parseContentElements","contentBlocks","contentRegex","urlRegex","serverRegex","licenseRegex","elementCount","match","attrs","body","urlMatch","serverMatch","licenseMatch","missing","findBestMatchingContent","parsed","host","path","bestMatch","bestSpecificity","block","patternUrl","patternPath","prefix","specificity","obtainLicenseToken","clientId","clientSecret","resourceUrl","debug","xml","fetchLicenseXml","contentBlocks","parseContentElements","matchedContent","findBestMatchingContent","patterns","b","tokenEndpoint","payload","requestOptions","retrieveLicenseToken","jwksCache","buildFetchOptions","options","FASTLY_BACKEND","fetchAndCacheJwks","cacheKey","url","debug","failureMessage","logLabel","response","jwksData","error","fetchPlatformJwks","baseUrl","jwksUrl","stripTrailingSlash","value","verifyLicenseToken","licenseToken","requestUrl","supertabBaseUrl","debug","decodeProtectedHeader","decodeJwt","jwtVerify","loadJose","header","error","payload","licenseId","issuer","normalizedIssuer","normalizedBaseUrl","audienceValues","entry","requestUrlNormalized","normalizedAudience","jwks","fetchPlatformJwks","result","jwtHeader","jwk","key","generateLicenseLink","baseURL","buildSignalResult","licenseLink","buildBlockResult","reason","rslError","errorDescription","status","buildFetchOptions","options","FASTLY_BACKEND","hostRSLicenseXML","merchantSystemUrn","licenseUrl","response","licenseXml","validateTokenAndBuildResult","params","verification","eventName","eventProperties","eventPromise","handleCloudflareRequest","handler","request","ctx","result","originResponse","response","key","value","handleFastlyRequest","originBackend","rslOptions","hostRSLicenseXML","handleCloudfrontRequest","event","cfRequest","url","headers","values","webRequest","responseHeaders","defaultBotDetector","request","userAgent","accept","secChUa","acceptLanguage","botScore","botList","lowerCaseUserAgent","botUaMatch","bot","headlessIndicators","isBrowserMissingSecChUa","missingHeaders","lowBotScore","_SupertabConnect","config","reset","url","licenseToken","requestUrl","verifyLicenseToken","eventName","properties","licenseId","payload","options","FASTLY_BACKEND","response","error","request","ctx","auth","token","userAgent","validateTokenAndBuildResult","buildBlockResult","buildSignalResult","clientId","clientSecret","resourceUrl","debug","obtainLicenseToken","env","instance","handleCloudflareRequest","merchantSystemUrn","merchantApiKey","originBackend","enableRSL","botDetector","enforcement","handleFastlyRequest","event","handleCloudfrontRequest","SupertabConnect"]}