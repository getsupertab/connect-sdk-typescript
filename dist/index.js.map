{"version":3,"sources":["../src/types.ts","../src/index.ts","../src/customer.ts","../src/license.ts","../src/jwks.ts"],"sourcesContent":["export interface SupertabConnectConfig {\n  apiKey: string;\n  merchantSystemUrn: string;\n}\n\n/**\n * Defines the shape for environment variables (used in CloudFlare integration).\n * These are used to identify and authenticate the Merchant System with the Supertab Connect API.\n */\nexport interface Env {\n\t/** The unique identifier for the merchant system. */\n\tMERCHANT_SYSTEM_URN: string;\n\t/** The API key for authenticating with the Supertab Connect. */\n\tMERCHANT_API_KEY: string;\n\t[key: string]: string;\n}\n\nexport interface EventPayload {\n  event_name: string;\n  license_id?: string;\n  merchant_system_urn: string;\n  properties: Record<string, any>;\n}\n\nexport interface TokenVerificationResult {\n  valid: boolean;\n  reason?: string;\n  payload?: any;\n}\n\nexport enum TokenInvalidReason {\n  MISSING_TOKEN = \"missing_token\",\n  INVALID_HEADER = \"invalid_header\",\n  INVALID_ALG = \"invalid_algorithm\",\n  INVALID_PAYLOAD = \"invalid_payload\",\n  INVALID_ISSUER = \"invalid_issuer\",\n  SIGNATURE_VERIFICATION_FAILED = \"signature_verification_failed\",\n  EXPIRED = \"token_expired\",\n}\n\nexport interface LicenseTokenVerificationResult {\n  valid: boolean;\n  reason?: string;\n  licenseId?: string;\n  payload?: any;\n}\n\nexport enum LicenseTokenInvalidReason {\n  MISSING_TOKEN = \"missing_license_token\",\n  INVALID_HEADER = \"invalid_license_header\",\n  INVALID_ALG = \"invalid_license_algorithm\",\n  INVALID_PAYLOAD = \"invalid_license_payload\",\n  INVALID_ISSUER = \"invalid_license_issuer\",\n  SIGNATURE_VERIFICATION_FAILED = \"license_signature_verification_failed\",\n  EXPIRED = \"license_token_expired\",\n  INVALID_AUDIENCE = \"invalid_license_audience\",\n}\n\nexport const FASTLY_BACKEND = \"stc-backend\";\n\nexport interface FetchOptions extends RequestInit {\n  // Fastly-specific extension for backend routing\n  backend?: string;\n}","import {\n  SupertabConnectConfig,\n  Env,\n  EventPayload,\n  TokenVerificationResult,\n  TokenInvalidReason,\n  FASTLY_BACKEND,\n} from \"./types\";\nimport {\n  jwtVerify,\n  decodeProtectedHeader,\n  decodeJwt,\n  JWTHeaderParameters,\n  JWTPayload,\n} from \"jose\";\nimport {\n  generateLicenseToken as generateLicenseTokenHelper,\n  generateCustomerJWT as generateCustomerJWTHelper,\n} from \"./customer\";\nimport {\n  baseLicenseHandleRequest as baseLicenseHandleRequestHelper,\n  hostRSLicenseXML as hostRSLicenseXMLHelper,\n} from \"./license\";\nimport { fetchIssuerJwks, fetchPlatformJwks } from \"./jwks\";\n\nexport type { Env } from \"./types\";\n\nconst debug = true; // Set to true for debugging purposes\n\n/**\n * SupertabConnect class provides higher level methods\n * for using Supertab Connect within supported CDN integrations\n * as well as more specialized methods to customarily verify JWT tokens and record events.\n */\nexport class SupertabConnect {\n  private apiKey?: string;\n  private static baseUrl: string = \"https://api-connect.supertab.co\";\n  private merchantSystemUrn!: string;\n\n  private static _instance: SupertabConnect | null = null;\n\n  public constructor(config: SupertabConnectConfig, reset: boolean = false) {\n    if (!reset && SupertabConnect._instance) {\n      // If reset was not requested and an instance conflicts with the provided config, throw an error\n      if (\n        !(\n          config.apiKey === SupertabConnect._instance.apiKey &&\n          config.merchantSystemUrn ===\n            SupertabConnect._instance.merchantSystemUrn\n        )\n      ) {\n        throw new Error(\n          \"Cannot create a new instance with different configuration. Use resetInstance to clear the existing instance.\"\n        );\n      }\n\n      // If an instance already exists and reset is not requested, just return the existing instance\n      return SupertabConnect._instance;\n    }\n    if (reset && SupertabConnect._instance) {\n      // ...and if reset is requested and required, clear the existing instance first\n      SupertabConnect.resetInstance();\n    }\n\n    if (!config.apiKey || !config.merchantSystemUrn) {\n      throw new Error(\n        \"Missing required configuration: apiKey and merchantSystemUrn are required\"\n      );\n    }\n    this.apiKey = config.apiKey;\n    this.merchantSystemUrn = config.merchantSystemUrn;\n\n    // Register this as the singleton instance\n    SupertabConnect._instance = this;\n  }\n\n  public static resetInstance(): void {\n    SupertabConnect._instance = null;\n  }\n\n  /**\n   * Override the default base URL for API requests (intended for local development/testing).\n   */\n  public static setBaseUrl(url: string): void {\n    SupertabConnect.baseUrl = url;\n  }\n\n  /**\n   * Verify a JWT token\n   * @param token The JWT token to verify\n   * @returns A promise that resolves with the verification result\n   */\n  async verifyToken(token: string): Promise<TokenVerificationResult> {\n    // 1. Check if token exists\n    if (!token) {\n      return {\n        valid: false,\n        reason: TokenInvalidReason.MISSING_TOKEN,\n      };\n    }\n\n    // 2. Verify header and algorithm\n    let header: JWTHeaderParameters;\n    try {\n      header = decodeProtectedHeader(token) as JWTHeaderParameters;\n    } catch (error) {\n      if (debug) {\n        console.error(\"Invalid JWT header:\", error);\n      }\n      return {\n        valid: false,\n        reason: TokenInvalidReason.INVALID_HEADER,\n      };\n    }\n\n    if (header.alg !== \"RS256\") {\n      return {\n        valid: false,\n        reason: TokenInvalidReason.INVALID_ALG,\n      };\n    }\n\n    // 3. Verify payload and issuer\n    let payload: JWTPayload;\n    try {\n      payload = decodeJwt(token);\n    } catch (error) {\n      if (debug) {\n        console.error(\"Invalid JWT payload:\", error);\n      }\n      return {\n        valid: false,\n        reason: TokenInvalidReason.INVALID_PAYLOAD,\n      };\n    }\n\n    const issuer: string | undefined = payload.iss;\n    if (!issuer || !issuer.startsWith(\"urn:stc:customer:\")) {\n      return {\n        valid: false,\n        reason: TokenInvalidReason.INVALID_ISSUER,\n      };\n    }\n\n    // 4. Verify signature\n    try {\n      const jwks = await fetchIssuerJwks(\n        SupertabConnect.baseUrl,\n        issuer,\n        debug\n      );\n\n      // Create a key finder function for verification\n      const getKey = async (header: JWTHeaderParameters) => {\n        const jwk = jwks.keys.find((key: any) => key.kid === header.kid);\n        if (!jwk) throw new Error(`No matching key found: ${header.kid}`);\n        return jwk;\n      };\n\n      const result = await jwtVerify(token, getKey, {\n        issuer,\n        algorithms: [\"RS256\"],\n        clockTolerance: \"1m\",\n      });\n\n      // Success case - token is valid\n      return {\n        valid: true,\n        payload: result.payload,\n      };\n    } catch (error: any) {\n      if (debug) {\n        console.error(\"JWT verification failed:\", error);\n      }\n\n      // Check if token is expired\n      if (error.message?.includes(\"exp\")) {\n        return {\n          valid: false,\n          reason: TokenInvalidReason.EXPIRED,\n        };\n      }\n\n      return {\n        valid: false,\n        reason: TokenInvalidReason.SIGNATURE_VERIFICATION_FAILED,\n      };\n    }\n  }\n\n  /**\n   * Records an analytics event\n   * @param eventName Name of the event to record\n   * @param properties Additional properties to include with the event\n   * @param licenseId Optional license ID associated with the event\n   * @returns Promise that resolves when the event is recorded\n   */\n  async recordEvent(\n    eventName: string,\n    properties: Record<string, any> = {},\n    licenseId?: string\n  ): Promise<void> {\n    const payload: EventPayload = {\n      event_name: eventName,\n      merchant_system_urn: this.merchantSystemUrn ? this.merchantSystemUrn : \"\",\n      license_id: licenseId,\n      properties,\n    };\n\n    try {\n      let options: any = {\n        method: \"POST\",\n        headers: {\n          Authorization: `Bearer ${this.apiKey}`,\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify(payload),\n      };\n      // @ts-ignore\n      if (globalThis?.fastly) {\n        options = { ...options, backend: FASTLY_BACKEND };\n      }\n      const response = await fetch(\n        `${SupertabConnect.baseUrl}/events`,\n        options\n      );\n\n      if (!response.ok) {\n        console.log(`Failed to record event: ${response.status}`);\n      }\n    } catch (error) {\n      console.log(\"Error recording event:\", error);\n    }\n  }\n\n  /**\n   * Handle the request, report an event to Supertab Connect and return a response\n   */\n  private async baseHandleRequest(\n    token: string,\n    url: string,\n    user_agent: string,\n    ctx: any\n  ): Promise<Response> {\n    // 1. Verify token\n    const verification = await this.verifyToken(token);\n\n    // Record event helper\n    async function recordEvent(\n      stc: SupertabConnect,\n      eventName: string,\n      ctx: any\n    ) {\n      const eventProperties = {\n        page_url: url,\n        user_agent: user_agent,\n        verification_status: verification.valid ? \"valid\" : \"invalid\",\n        verification_reason: verification.reason || \"success\",\n      };\n      if (ctx) {\n        const eventPromise = stc.recordEvent(eventName, eventProperties);\n        ctx.waitUntil(eventPromise);\n        return eventPromise;\n      } else {\n        return await stc.recordEvent(eventName, eventProperties);\n      }\n    }\n\n    // 2. Handle based on verification result\n    if (!verification.valid) {\n      await recordEvent(\n        this,\n        verification.reason || \"token_verification_failed\",\n        ctx\n      );\n      const message =\n        \"Payment required: you need to present a valid Supertab Connect token to access this content. \" +\n        \"Check out the provided url for details\";\n      const details =\n        \"❌ Content access denied\" +\n        (verification.reason ? `: ${verification.reason}` : \"\");\n      const contentAccessUrl = `${SupertabConnect.baseUrl}/merchants/systems/${this.merchantSystemUrn}/content-access.json`;\n\n      const responseBody = {\n        url: contentAccessUrl,\n        message: message,\n        details: details,\n      };\n\n      return new Response(JSON.stringify(responseBody), {\n        status: 402,\n        headers: new Headers({ \"Content-Type\": \"application/json\" }),\n      });\n    }\n\n    // 3. Success\n    await recordEvent(this, \"page_viewed\", ctx);\n    return new Response(\"✅ Content Access granted\", {\n      status: 200,\n      headers: new Headers({ \"Content-Type\": \"application/json\" }),\n    });\n  }\n\n  /**\n   * Handle the request for license tokens, report an event to Supertab Connect and return a response\n   */\n  private async baseLicenseHandleRequest(\n    licenseToken: string,\n    url: string,\n    user_agent: string,\n    ctx: any\n  ): Promise<Response> {\n    return baseLicenseHandleRequestHelper({\n      licenseToken,\n      url,\n      userAgent: user_agent,\n      ctx,\n      supertabBaseUrl: SupertabConnect.baseUrl,\n      merchantSystemUrn: this.merchantSystemUrn,\n      debug,\n      recordEvent: (\n        eventName: string,\n        properties?: Record<string, any>,\n        licenseId?: string\n      ) => this.recordEvent(eventName, properties, licenseId),\n    });\n  }\n\n  private extractDataFromRequest(request: Request): {\n    token: string;\n    licenseToken: string;\n    url: string;\n    user_agent: string;\n  } {\n    // Parse token\n    const auth = request.headers.get(\"Authorization\") || \"\";\n    const token = auth.startsWith(\"Bearer \") ? auth.slice(7) : \"\";\n    const licenseToken = auth.startsWith(\"License \") ? auth.slice(8) : \"\";\n\n    // Extract URL and user agent\n    const url = request.url;\n    const user_agent = request.headers.get(\"User-Agent\") || \"unknown\";\n\n    return { token, licenseToken, url, user_agent };\n  }\n\n  static checkIfBotRequest(request: Request): boolean {\n    const userAgent = request.headers.get(\"User-Agent\") || \"\";\n    const accept = request.headers.get(\"accept\") || \"\";\n    const secChUa = request.headers.get(\"sec-ch-ua\");\n    const acceptLanguage = request.headers.get(\"accept-language\");\n    const botScore = (request as any).cf?.botManagement?.score;\n\n    const botList = [\n      \"chatgpt-user\",\n      \"perplexitybot\",\n      \"gptbot\",\n      \"anthropic-ai\",\n      \"ccbot\",\n      \"claude-web\",\n      \"claudebot\",\n      \"cohere-ai\",\n      \"youbot\",\n      \"diffbot\",\n      \"oai-searchbot\",\n      \"meta-externalagent\",\n      \"timpibot\",\n      \"amazonbot\",\n      \"bytespider\",\n      \"perplexity-user\",\n      \"googlebot\",\n      \"bot\",\n      \"curl\",\n      \"wget\",\n    ];\n    // 1. Basic substring check from known list\n    const lowerCaseUserAgent = userAgent.toLowerCase();\n    const botUaMatch = botList.some((bot) => lowerCaseUserAgent.includes(bot));\n\n    // 2. Headless browser detection\n    const headlessIndicators =\n      userAgent.toLowerCase().includes(\"headless\") ||\n      userAgent.toLowerCase().includes(\"puppeteer\") ||\n      !secChUa;\n\n    const only_sec_ch_ua_missing =\n      !userAgent.toLowerCase().includes(\"headless\") ||\n      !userAgent.toLowerCase().includes(\"puppeteer\") ||\n      !secChUa;\n\n    // 3. Suspicious header gaps — many bots omit these\n    const missingHeaders = !accept || !acceptLanguage;\n\n    // 4. Cloudflare bot score check (if available)\n    const lowBotScore = typeof botScore === \"number\" && botScore < 30;\n    console.log(\"Bot Detection Details:\", {\n      botUaMatch,\n      headlessIndicators,\n      missingHeaders,\n      lowBotScore,\n      botScore,\n    });\n\n    // Safari and Mozilla special case\n    if (\n      lowerCaseUserAgent.includes(\"safari\") ||\n      lowerCaseUserAgent.includes(\"mozilla\")\n    ) {\n      // Safari is not a bot, but it may be headless\n      if (headlessIndicators && only_sec_ch_ua_missing) {\n        return false; // Likely not a bot, but missing a Sec-CH-UA header\n      }\n    }\n\n    // Final decision\n    return botUaMatch || headlessIndicators || missingHeaders || lowBotScore;\n  }\n\n  static async cloudflareHandleRequests(\n    request: Request,\n    env: Env,\n    ctx: any\n  ): Promise<Response> {\n    // Validate required env variables\n    const { MERCHANT_SYSTEM_URN, MERCHANT_API_KEY } = env;\n\n    // Prepare or get the SupertabConnect instance\n    const supertabConnect = new SupertabConnect({\n      apiKey: MERCHANT_API_KEY,\n      merchantSystemUrn: MERCHANT_SYSTEM_URN,\n    });\n\n    // Handle the request, including bot detection, token verification and recording the event\n    return supertabConnect.handleRequest(\n      request,\n      SupertabConnect.checkIfBotRequest,\n      ctx\n    );\n  }\n\n  static async fastlyHandleRequests(\n    request: Request,\n    merchantSystemUrn: string,\n    merchantApiKey: string,\n    enableRSL: boolean = false,\n  ): Promise<Response> {\n    // Prepare or get the SupertabConnect instance\n    const supertabConnect = new SupertabConnect({\n      apiKey: merchantApiKey,\n      merchantSystemUrn: merchantSystemUrn,\n    });\n\n    if (enableRSL) {\n      if (new URL(request.url).pathname === \"/license.xml\") {\n        return await hostRSLicenseXMLHelper(\n          SupertabConnect.baseUrl,\n          merchantSystemUrn\n        );\n      }\n    }\n\n    // Handle the request, including bot detection, token verification and recording the event\n    return supertabConnect.handleRequest(\n      request,\n      SupertabConnect.checkIfBotRequest,\n      null\n    );\n  }\n\n  async handleRequest(\n    request: Request,\n    botDetectionHandler?: (request: Request, ctx?: any) => boolean,\n    ctx?: any\n  ): Promise<Response> {\n    // 1. Extract token, license token, URL, and user agent from the request\n    const { token, licenseToken, url, user_agent } =\n      this.extractDataFromRequest(request);\n\n    // 2. Handle bot detection if provided\n    if (botDetectionHandler && !botDetectionHandler(request, ctx)) {\n      return new Response(\"✅ Non-Bot Content Access granted\", {\n        status: 200,\n        headers: new Headers({ \"Content-Type\": \"application/json\" }),\n      });\n    }\n\n    // 3. Check for bearer token first, then fallback to license token\n    if (token) {\n      return this.baseHandleRequest(token, url, user_agent, ctx);\n    }\n\n    // 4. Call the base licenhandle request method and return the result\n    return this.baseLicenseHandleRequest(licenseToken, url, user_agent, ctx);\n  }\n\n  async hostRSLicenseXML(): Promise<Response> {\n    return hostRSLicenseXMLHelper(\n      SupertabConnect.baseUrl,\n      this.merchantSystemUrn\n    );\n  }\n\n  /**\n   * Request a license token from the Supertab Connect token endpoint.\n   * @param clientId OAuth client identifier used for the assertion issuer/subject claims.\n   * @param kid The key ID to include in the JWT header.\n   * @param privateKeyPem Private key in PEM format used to sign the client assertion.\n   * @param tokenEndpoint Token endpoint URL.\n   * @param resourceUrl Resource URL attempting to access with a License.\n   * @param licenseXml XML license document to include in the request payload.\n   * @returns Promise resolving to the issued license access token string.\n   */\n  static async generateLicenseToken(\n    clientId: string,\n    kid: string,\n    privateKeyPem: string,\n    resourceUrl: string,\n    licenseXml: string\n  ): Promise<string> {\n    const tokenEndpoint = SupertabConnect.baseUrl + \"/rsl/token\";\n    return generateLicenseTokenHelper({\n      clientId,\n      kid,\n      privateKeyPem,\n      tokenEndpoint,\n      resourceUrl,\n      licenseXml,\n      debug,\n    });\n  }\n\n\n  /** Generate a customer JWT\n   * @param customerURN The customer's unique resource name (URN).\n   * @param kid The key ID to include in the JWT header.\n   * @param privateKeyPem The private key in PEM format used to sign the JWT.\n   * @param expirationSeconds The token's expiration time in seconds (default is 3600 seconds).\n   * @returns A promise that resolves to the generated JWT as a string.\n   */\n  static async generateCustomerJWT(\n    customerURN: string,\n    kid: string,\n    privateKeyPem: string,\n    expirationSeconds: number = 3600\n  ): Promise<string> {\n    return generateCustomerJWTHelper({\n      customerURN,\n      kid,\n      privateKeyPem,\n      expirationSeconds,\n    });\n  }\n}\n","import { importPKCS8, SignJWT } from \"jose\";\n\ntype SupportedAlg = \"RS256\" | \"ES256\";\n\ntype GenerateLicenseTokenParams = {\n  clientId: string;\n  kid: string;\n  privateKeyPem: string;\n  tokenEndpoint: string;\n  resourceUrl: string;\n  licenseXml: string;\n  debug?: boolean;\n};\n\ntype GenerateCustomerJwtParams = {\n  customerURN: string;\n  kid: string;\n  privateKeyPem: string;\n  expirationSeconds?: number;\n};\n\nasync function importKeyForAlgs(\n  privateKeyPem: string,\n  debug: boolean | undefined\n): Promise<{ key: CryptoKey; alg: SupportedAlg }> {\n  const supportedAlgs: SupportedAlg[] = [\"ES256\", \"RS256\"];\n\n  for (const algorithm of supportedAlgs) {\n    try {\n      const key = await importPKCS8(privateKeyPem, algorithm);\n      return { key, alg: algorithm };\n    } catch (importError) {\n      if (debug) {\n        console.debug(\n          `Private key did not import using ${algorithm}, retrying...`,\n          importError\n        );\n      }\n    }\n  }\n\n  throw new Error(\n    \"Unsupported private key format. Expected RSA or P-256 EC private key.\"\n  );\n}\n\nexport async function generateLicenseToken({\n  clientId,\n  kid,\n  privateKeyPem,\n  tokenEndpoint,\n  resourceUrl,\n  licenseXml,\n  debug,\n}: GenerateLicenseTokenParams): Promise<string> {\n  const { key, alg } = await importKeyForAlgs(privateKeyPem, debug);\n  const now = Math.floor(Date.now() / 1000);\n\n  const clientAssertion = await new SignJWT({})\n    .setProtectedHeader({ alg, kid })\n    .setIssuer(clientId)\n    .setSubject(clientId)\n    .setIssuedAt(now)\n    .setExpirationTime(now + 300)\n    .setAudience(tokenEndpoint)\n    .sign(key);\n\n  const payload = new URLSearchParams({\n    grant_type: \"rsl\",\n    client_assertion_type:\n      \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\",\n    client_assertion: clientAssertion,\n    license: licenseXml,\n    resource: resourceUrl,\n  });\n\n  const requestOptions: RequestInit = {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/x-www-form-urlencoded\",\n      Accept: \"application/json\",\n    },\n    body: payload.toString(),\n  };\n\n  try {\n    const response = await fetch(tokenEndpoint, requestOptions);\n\n    if (!response.ok) {\n      const errorBody = await response.text().catch(() => \"\");\n      const errorMessage = `Failed to obtain license token: ${\n        response.status\n      } ${response.statusText}${errorBody ? ` - ${errorBody}` : \"\"}`;\n      throw new Error(errorMessage);\n    }\n\n    let data: any;\n    try {\n      data = await response.json();\n    } catch (parseError) {\n      if (debug) {\n        console.error(\n          \"Failed to parse license token response as JSON:\",\n          parseError\n        );\n      }\n      throw new Error(\"Failed to parse license token response as JSON\");\n    }\n\n    if (!data?.access_token) {\n      throw new Error(\"License token response missing access_token\");\n    }\n\n    return data.access_token;\n  } catch (error) {\n    if (debug) {\n      console.error(\"Error generating license token:\", error);\n    }\n    throw error;\n  }\n}\n\nexport async function generateCustomerJWT({\n  customerURN,\n  kid,\n  privateKeyPem,\n  expirationSeconds = 3600,\n}: GenerateCustomerJwtParams): Promise<string> {\n  const alg: SupportedAlg = \"RS256\";\n  const key = await importPKCS8(privateKeyPem, alg);\n\n  const now = Math.floor(Date.now() / 1000);\n\n  return new SignJWT({})\n    .setProtectedHeader({ alg, kid })\n    .setIssuer(customerURN)\n    .setIssuedAt(now)\n    .setExpirationTime(now + expirationSeconds)\n    .sign(key);\n}\n\nexport type { GenerateLicenseTokenParams, GenerateCustomerJwtParams };\n","import {\n  decodeProtectedHeader,\n  decodeJwt,\n  JWTPayload,\n  JWTHeaderParameters,\n  jwtVerify,\n} from \"jose\";\nimport {\n  LicenseTokenInvalidReason,\n  LicenseTokenVerificationResult,\n  FASTLY_BACKEND,\n  FetchOptions,\n} from \"./types\";\nimport { fetchPlatformJwks } from \"./jwks\";\n\nconst stripTrailingSlash = (value: string) => value.replace(/\\/+$/, \"\");\n\nexport type VerifyLicenseTokenParams = {\n  licenseToken: string;\n  requestUrl: string;\n  supertabBaseUrl: string;\n  debug: boolean;\n};\n\nexport async function verifyLicenseToken({\n  licenseToken,\n  requestUrl,\n  supertabBaseUrl,\n  debug,\n}: VerifyLicenseTokenParams): Promise<LicenseTokenVerificationResult> {\n  if (!licenseToken) {\n    return {\n      valid: false,\n      reason: LicenseTokenInvalidReason.MISSING_TOKEN,\n    };\n  }\n\n  let header: JWTHeaderParameters;\n  try {\n    header = decodeProtectedHeader(licenseToken) as JWTHeaderParameters;\n  } catch (error) {\n    if (debug) {\n      console.error(\"Invalid license JWT header:\", error);\n    }\n    return {\n      valid: false,\n      reason: LicenseTokenInvalidReason.INVALID_HEADER,\n    };\n  }\n\n  if (header.alg !== \"ES256\") {\n    if (debug) {\n      console.error(\"Unsupported license JWT alg:\", header.alg);\n    }\n    return {\n      valid: false,\n      reason: LicenseTokenInvalidReason.INVALID_ALG,\n    };\n  }\n\n  let payload: JWTPayload;\n  try {\n    payload = decodeJwt(licenseToken);\n  } catch (error) {\n    if (debug) {\n      console.error(\"Invalid license JWT payload:\", error);\n    }\n    return {\n      valid: false,\n      reason: LicenseTokenInvalidReason.INVALID_PAYLOAD,\n    };\n  }\n\n  // @ts-ignore\n  const licenseId: string | undefined = payload.license_id;\n\n  const issuer: string | undefined = payload.iss;\n  if (!issuer || !issuer.startsWith(supertabBaseUrl)) {\n    if (debug) {\n      console.error(\"Invalid license JWT issuer:\", issuer);\n    }\n    return {\n      valid: false,\n      reason: LicenseTokenInvalidReason.INVALID_ISSUER,\n      licenseId,\n    };\n  }\n\n  const audienceValues = Array.isArray(payload.aud)\n    ? payload.aud.filter((entry): entry is string => typeof entry === \"string\")\n    : typeof payload.aud === \"string\"\n    ? [payload.aud]\n    : [];\n\n  const requestUrlNormalized = stripTrailingSlash(requestUrl);\n  const matchesRequestUrl = audienceValues.some((value) => {\n    const normalizedAudience = stripTrailingSlash(value);\n    if (!normalizedAudience) return false;\n    return requestUrlNormalized.startsWith(normalizedAudience);\n  });\n\n  if (!matchesRequestUrl) {\n    if (debug) {\n      console.error(\n        \"License JWT audience does not match request URL:\",\n        payload.aud\n      );\n    }\n    return {\n      valid: false,\n      reason: LicenseTokenInvalidReason.INVALID_AUDIENCE,\n      licenseId,\n    };\n  }\n\n  try {\n    const jwks = await fetchPlatformJwks(supertabBaseUrl, debug);\n\n    const getKey = async (jwtHeader: JWTHeaderParameters) => {\n      const jwk = jwks.keys.find((key: any) => key.kid === jwtHeader.kid);\n      if (!jwk) {\n        throw new Error(`No matching platform key found: ${jwtHeader.kid}`);\n      }\n      return jwk;\n    };\n\n    const result = await jwtVerify(licenseToken, getKey, {\n      issuer,\n      algorithms: [header.alg],\n      clockTolerance: \"1m\",\n    });\n\n    return {\n      valid: true,\n      licenseId,\n      payload: result.payload,\n    };\n  } catch (error) {\n    if (debug) {\n      console.error(\"License JWT verification failed:\", error);\n    }\n\n    if (error instanceof Error && error.message?.includes(\"exp\")) {\n      return {\n        valid: false,\n        reason: LicenseTokenInvalidReason.EXPIRED,\n        licenseId,\n      };\n    }\n\n    return {\n      valid: false,\n      reason: LicenseTokenInvalidReason.SIGNATURE_VERIFICATION_FAILED,\n      licenseId,\n    };\n  }\n}\n\nexport function generateLicenseLink({\n  requestUrl,\n}: {\n  requestUrl: string;\n}): string {\n  const baseURL = new URL(requestUrl);\n  return `${baseURL.protocol}//${baseURL.host}/license.xml`;\n}\n\ntype RecordEventFn = (\n  eventName: string,\n  properties?: Record<string, any>,\n  licenseId?: string\n) => Promise<void>;\n\ntype BaseLicenseHandleRequestParams = {\n  licenseToken: string;\n  url: string;\n  userAgent: string;\n  ctx: any;\n  supertabBaseUrl: string;\n  merchantSystemUrn?: string;\n  debug: boolean;\n  recordEvent: RecordEventFn;\n};\n\nexport async function baseLicenseHandleRequest({\n  licenseToken,\n  url,\n  userAgent,\n  ctx,\n  supertabBaseUrl,\n  merchantSystemUrn,\n  debug,\n  recordEvent,\n}: BaseLicenseHandleRequestParams): Promise<Response> {\n  const verification = await verifyLicenseToken({\n    licenseToken,\n    requestUrl: url,\n    supertabBaseUrl,\n    debug,\n  });\n\n  async function recordLicenseEvent(eventName: string) {\n    const eventProperties = {\n      page_url: url,\n      user_agent: userAgent,\n      verification_status: verification.valid ? \"valid\" : \"invalid\",\n      verification_reason: verification.reason || \"success\",\n    };\n\n    const eventPromise = recordEvent(\n      eventName,\n      eventProperties,\n      verification.licenseId\n    );\n\n    if (ctx?.waitUntil) {\n      ctx.waitUntil(eventPromise);\n    }\n\n    return eventPromise;\n  }\n\n  if (!verification.valid) {\n    await recordLicenseEvent(\n      verification.reason || \"license_token_verification_failed\"\n    );\n\n    let rslError = \"invalid_request\";\n    let errorDescription = \"Access to this resource requires a license\";\n\n    switch (verification.reason) {\n      case LicenseTokenInvalidReason.MISSING_TOKEN:\n        rslError = \"invalid_request\";\n        errorDescription = \"Access to this resource requires a license\";\n        break;\n      case LicenseTokenInvalidReason.EXPIRED:\n        rslError = \"invalid_token\";\n        errorDescription = \"The license token has expired\";\n        break;\n      case LicenseTokenInvalidReason.SIGNATURE_VERIFICATION_FAILED:\n        rslError = \"invalid_token\";\n        errorDescription = \"The license token signature is invalid\";\n        break;\n      case LicenseTokenInvalidReason.INVALID_HEADER:\n        rslError = \"invalid_token\";\n        errorDescription = \"The license token header is invalid\";\n        break;\n      case LicenseTokenInvalidReason.INVALID_PAYLOAD:\n        rslError = \"invalid_token\";\n        errorDescription = \"The license token payload is invalid\";\n        break;\n      case LicenseTokenInvalidReason.INVALID_ISSUER:\n        rslError = \"invalid_token\";\n        errorDescription = \"The license token issuer is invalid\";\n        break;\n      case LicenseTokenInvalidReason.INVALID_AUDIENCE:\n        rslError = \"invalid_token\";\n        errorDescription = \"The license token audience is invalid\";\n        break;\n      default:\n        rslError = \"invalid_request\";\n        errorDescription = \"Access to this resource requires a license\";\n    }\n\n    const licenseLink = generateLicenseLink({\n      requestUrl: url,\n    });\n    const errorUri = `${supertabBaseUrl}/docs/errors#${rslError}`;\n\n    const headers = new Headers({\n      \"Content-Type\": \"text/plain; charset=UTF-8\",\n      \"WWW-Authenticate\": `License error=\"${rslError}\", error_description=\"${errorDescription}\", error_uri=\"${errorUri}\"`,\n      Link: `${licenseLink}; rel=\"license\"; type=\"application/rsl+xml\"`,\n    });\n\n    const responseBody = `Access to this resource requires a valid license token. Error: ${rslError} - ${errorDescription}`;\n\n    return new Response(responseBody, {\n      status: 401,\n      headers,\n    });\n  }\n\n  await recordLicenseEvent(\"license_used\");\n  return new Response(\"✅ License Token Access granted\", {\n    status: 200,\n    headers: new Headers({ \"Content-Type\": \"application/json\" }),\n  });\n}\n\nfunction buildFetchOptions(): FetchOptions {\n  let options: FetchOptions = { method: \"GET\" };\n  // @ts-ignore - backend is a Fastly-specific extension\n  if (globalThis?.fastly) {\n    options = { ...options, backend: FASTLY_BACKEND };\n  }\n  return options;\n}\n\nexport async function hostRSLicenseXML(\n  supertabBaseUrl: string,\n  merchantSystemUrn: string\n): Promise<Response> {\n  const licenseUrl = `${supertabBaseUrl}/merchants/systems/${merchantSystemUrn}/license.xml`;\n  const response = await fetch(licenseUrl, buildFetchOptions());\n\n  if (!response.ok) {\n    return new Response(\"License not found\", { status: 404 });\n  }\n\n  const licenseXml = await response.text();\n\n  return new Response(licenseXml, {\n    status: 200,\n    headers: new Headers({ \"Content-Type\": \"application/xml\" }),\n  });\n}\n","import { FASTLY_BACKEND, FetchOptions } from \"./types\";\n\nconst jwksCache = new Map<string, any>();\n\ntype JwksCacheKey = string;\n\ntype FetchJwksParams = {\n  cacheKey: JwksCacheKey;\n  url: string;\n  debug: boolean;\n  failureMessage: string;\n  logLabel: string;\n};\n\nfunction buildFetchOptions(): FetchOptions {\n  let options: FetchOptions = { method: \"GET\" };\n  // @ts-ignore - backend is a Fastly-specific extension\n  if (globalThis?.fastly) {\n    options = { ...options, backend: FASTLY_BACKEND };\n  }\n  return options;\n}\n\nasync function fetchAndCacheJwks({\n  cacheKey,\n  url,\n  debug,\n  failureMessage,\n  logLabel,\n}: FetchJwksParams): Promise<any> {\n  if (!jwksCache.has(cacheKey)) {\n    try {\n      const response = await fetch(url, buildFetchOptions());\n\n      if (!response.ok) {\n        throw new Error(`${failureMessage}: ${response.status}`);\n      }\n\n      const jwksData = await response.json();\n      jwksCache.set(cacheKey, jwksData);\n    } catch (error) {\n      if (debug) {\n        console.error(logLabel, error);\n      }\n      throw error;\n    }\n  }\n\n  return jwksCache.get(cacheKey);\n}\n\nexport async function fetchIssuerJwks(\n  baseUrl: string,\n  issuer: string,\n  debug: boolean\n): Promise<any> {\n  const jwksUrl = `${baseUrl}/.well-known/jwks.json/${encodeURIComponent(\n    issuer\n  )}`;\n\n  return fetchAndCacheJwks({\n    cacheKey: issuer,\n    url: jwksUrl,\n    debug,\n    failureMessage: \"Failed to fetch JWKS\",\n    logLabel: \"Error fetching JWKS:\",\n  });\n}\n\nexport async function fetchPlatformJwks(\n  baseUrl: string,\n  debug: boolean\n): Promise<any> {\n  const jwksUrl = `${baseUrl}/.well-known/jwks.json/platform`;\n  console.log(\"Fetching platform JWKS from:\", jwksUrl);\n\n  return fetchAndCacheJwks({\n    cacheKey: \"platform_jwks\",\n    url: jwksUrl,\n    debug,\n    failureMessage: \"Failed to fetch platform JWKS\",\n    logLabel: \"Error fetching platform JWKS:\",\n  });\n}\n\nexport function clearJwksCache(): void {\n  jwksCache.clear();\n}\n"],"mappings":"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","names":["FASTLY_BACKEND","jwtVerify","decodeProtectedHeader","decodeJwt","importPKCS8","SignJWT","importKeyForAlgs","privateKeyPem","debug","supportedAlgs","algorithm","importError","generateLicenseToken","clientId","kid","tokenEndpoint","resourceUrl","licenseXml","key","alg","now","clientAssertion","payload","requestOptions","response","errorBody","errorMessage","data","parseError","error","generateCustomerJWT","customerURN","expirationSeconds","decodeProtectedHeader","decodeJwt","jwtVerify","jwksCache","buildFetchOptions","options","FASTLY_BACKEND","fetchAndCacheJwks","cacheKey","url","debug","failureMessage","logLabel","response","jwksData","error","fetchIssuerJwks","baseUrl","issuer","jwksUrl","fetchPlatformJwks","stripTrailingSlash","value","verifyLicenseToken","licenseToken","requestUrl","supertabBaseUrl","debug","header","decodeProtectedHeader","error","payload","decodeJwt","licenseId","issuer","audienceValues","entry","requestUrlNormalized","normalizedAudience","jwks","fetchPlatformJwks","result","jwtVerify","jwtHeader","jwk","key","generateLicenseLink","baseURL","baseLicenseHandleRequest","url","userAgent","ctx","merchantSystemUrn","recordEvent","verification","recordLicenseEvent","eventName","eventProperties","eventPromise","rslError","errorDescription","licenseLink","errorUri","headers","responseBody","buildFetchOptions","options","FASTLY_BACKEND","hostRSLicenseXML","licenseUrl","response","licenseXml","debug","_SupertabConnect","config","reset","url","token","header","decodeProtectedHeader","error","payload","decodeJwt","issuer","jwks","fetchIssuerJwks","jwtVerify","jwk","key","eventName","properties","licenseId","options","FASTLY_BACKEND","response","user_agent","ctx","verification","recordEvent","stc","eventProperties","eventPromise","message","details","responseBody","licenseToken","baseLicenseHandleRequest","request","auth","userAgent","accept","secChUa","acceptLanguage","botScore","botList","lowerCaseUserAgent","botUaMatch","bot","headlessIndicators","only_sec_ch_ua_missing","missingHeaders","lowBotScore","env","MERCHANT_SYSTEM_URN","MERCHANT_API_KEY","merchantSystemUrn","merchantApiKey","enableRSL","supertabConnect","hostRSLicenseXML","botDetectionHandler","clientId","kid","privateKeyPem","resourceUrl","licenseXml","tokenEndpoint","generateLicenseToken","customerURN","expirationSeconds","generateCustomerJWT","SupertabConnect"]}