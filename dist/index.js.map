{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import {\n  SupertabConnectConfig,\n  EventPayload,\n  TokenVerificationResult,\n  TokenInvalidReason,\n} from \"./types\";\nimport {\n  jwtVerify,\n  decodeProtectedHeader,\n  decodeJwt,\n  JWTHeaderParameters,\n  JWTPayload,\n} from \"jose\";\n\n// In-memory cache for JWK sets\nconst jwksCache = new Map<string, any>();\n\nexport class SupertabConnect {\n  private apiKey: string;\n  private baseUrl: string;\n  private merchantSystemId: string;\n  private debug: boolean;\n\n  constructor(config: SupertabConnectConfig) {\n    this.apiKey = config.apiKey;\n    this.merchantSystemId = config.merchantSystemId;\n    this.baseUrl = config.baseUrl || \"https://api-connect.sbx.supertab.co\";\n    this.debug = config.debug || false;\n  }\n\n  /**\n   * Get the JWKS for a given issuer, using cache if available\n   * @private\n   */\n  private async getJwksForIssuer(issuer: string): Promise<any> {\n    if (!jwksCache.has(issuer)) {\n      const jwksUrl = `${\n        this.baseUrl\n      }/.well-known/jwks.json/${encodeURIComponent(issuer)}`;\n\n      try {\n        const jwksResponse = await fetch(jwksUrl);\n        if (!jwksResponse.ok) {\n          throw new Error(`Failed to fetch JWKS: ${jwksResponse.status}`);\n        }\n\n        const jwksData = await jwksResponse.json();\n        jwksCache.set(issuer, jwksData);\n      } catch (error) {\n        if (this.debug) {\n          console.error(\"Error fetching JWKS:\", error);\n        }\n        throw error;\n      }\n    }\n\n    return jwksCache.get(issuer);\n  }\n\n  /**\n   * Verify a JWT token\n   * @param token The JWT token to verify\n   * @returns A promise that resolves with the verification result\n   */\n  async verifyToken(token: string): Promise<TokenVerificationResult> {\n    // 1. Check if token exists\n    if (!token) {\n      return {\n        valid: false,\n        reason: TokenInvalidReason.MISSING_TOKEN,\n      };\n    }\n\n    // 2. Verify header and algorithm\n    let header: JWTHeaderParameters;\n    try {\n      header = decodeProtectedHeader(token) as JWTHeaderParameters;\n    } catch (error) {\n      if (this.debug) {\n        console.error(\"Invalid JWT header:\", error);\n      }\n      return {\n        valid: false,\n        reason: TokenInvalidReason.INVALID_HEADER,\n      };\n    }\n\n    if (header.alg !== \"RS256\") {\n      return {\n        valid: false,\n        reason: TokenInvalidReason.INVALID_ALG,\n      };\n    }\n\n    // 3. Verify payload and issuer\n    let payload: JWTPayload;\n    try {\n      payload = decodeJwt(token);\n    } catch (error) {\n      if (this.debug) {\n        console.error(\"Invalid JWT payload:\", error);\n      }\n      return {\n        valid: false,\n        reason: TokenInvalidReason.INVALID_PAYLOAD,\n      };\n    }\n\n    const issuer: string | undefined = payload.iss;\n    if (!issuer || !issuer.startsWith(\"urn:stc:customer:\")) {\n      return {\n        valid: false,\n        reason: TokenInvalidReason.INVALID_ISSUER,\n      };\n    }\n\n    // 4. Verify signature\n    try {\n      const jwks = await this.getJwksForIssuer(issuer);\n\n      // Create a key finder function for verification\n      const getKey = async (header: JWTHeaderParameters) => {\n        const jwk = jwks.keys.find((key: any) => key.kid === header.kid);\n        if (!jwk) throw new Error(`No matching key found: ${header.kid}`);\n        return jwk;\n      };\n\n      const result = await jwtVerify(token, getKey, {\n        issuer,\n        algorithms: [\"RS256\"],\n        clockTolerance: \"1m\",\n      });\n\n      // Success case - token is valid\n      return {\n        valid: true,\n        payload: result.payload,\n      };\n    } catch (error: any) {\n      if (this.debug) {\n        console.error(\"JWT verification failed:\", error);\n      }\n\n      // Check if token is expired\n      if (error.message?.includes(\"exp\")) {\n        return {\n          valid: false,\n          reason: TokenInvalidReason.EXPIRED,\n        };\n      }\n\n      return {\n        valid: false,\n        reason: TokenInvalidReason.SIGNATURE_VERIFICATION_FAILED,\n      };\n    }\n  }\n\n  /**\n   * Records an analytics event\n   * @param eventName Name of the event to record\n   * @param customerToken Optional customer token for the event\n   * @param properties Additional properties to include with the event\n   * @returns Promise that resolves when the event is recorded\n   */\n  async recordEvent(\n    eventName: string,\n    customerToken?: string,\n    properties: Record<string, any> = {}\n  ): Promise<void> {\n    const payload: EventPayload = {\n      event_name: eventName,\n      customer_system_token: customerToken,\n      merchant_system_identifier: this.merchantSystemId,\n      properties,\n    };\n\n    try {\n      const response = await fetch(`${this.baseUrl}/events`, {\n        method: \"POST\",\n        headers: {\n          Authorization: `Bearer ${this.apiKey}`,\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify(payload),\n      });\n\n      if (!response.ok) {\n        if (this.debug) {\n          console.error(`Failed to record event: ${response.status}`);\n        }\n      }\n    } catch (error) {\n      if (this.debug) {\n        console.error(\"Error recording event:\", error);\n      }\n    }\n  }\n}\n"],"mappings":"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","names":["index_exports","__export","SupertabConnect","__toCommonJS","import_jose","jwksCache","SupertabConnect","config","issuer","jwksUrl","jwksResponse","jwksData","error","token","header","payload","jwks","jwk","key","eventName","customerToken","properties","response"]}
